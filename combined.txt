// Path: ./srcs/c_hamou/utils.c
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: oait-si- <oait-si-@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/12 02:13:30 by oait-si-          #+#    #+#             */
/*   Updated: 2025/07/01 14:53:36 by oait-si-         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "header.h"

char	*question_mark(int ex_status)
{
	return (ft_itoa(ex_status));
}

int	get_quotes_type(char quote_type)
{
	if (quote_type == '"')
		return (2);
	return (1);
}

int	is_space(char c)
{
	return (c == ' ' || c == '\t');
}

int	is_operator(char c)
{
	return (c == '<' || c == '>' || c == '|');
}

int	is_quotes(char c)
{
	return (c == '"' || c == '\'');
}


// Path: ./srcs/c_hamou/commands_utils.c
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   commands_utils.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: oadouz <oadouz@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/01 21:49:05 by oait-si-          #+#    #+#             */
/*   Updated: 2025/07/10 10:41:55 by oadouz           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "header.h"

t_command	*new_command(void)
{
	t_command	*command;

	command = malloc(sizeof(t_command));
	if (!command)
		return (NULL);
	command->cmd = NULL;
	command->args = NULL;
	command->red_in = NULL;
	command->red_out = NULL;
	command->append = NULL;
	command->heredoc_delimiters = NULL;
	command->heredoc_quotes = NULL;
	command->heredoc_tmp_file = NULL;
	command->next = NULL;
	return (command);
}

void	add_command(t_command **commands, t_command *command)
{
	t_command	*tmp;

	if (!command)
		return ;
	if (!*commands)
		*commands = command;
	else
	{
		tmp = *commands;
		while (tmp->next)
			tmp = tmp->next;
		tmp->next = command;
	}
}

int	ensure_command_exists(t_cmd_builder *builder, t_token *token)
{
	if (builder->current)
		return (1);
	builder->current = new_command();
	if (!builder->current)
		return (0);
	add_command(&builder->commands, builder->current);
	builder->tokens_start = token;
	return (1);
}

void	terminate_arrays(t_command *cmd, t_indices *idx, t_counts counts)
{
	cmd->args[idx->i] = NULL;
	cmd->red_in[idx->j] = NULL;
	cmd->red_out[idx->k] = NULL;
	if (counts.heredoc_c > 0)
		cmd->heredoc_delimiters[idx->heredoc_idx] = NULL;
}

int	allocate_memory(t_command *cmd, t_counts counts)
{
	cmd->cmd = NULL;
	cmd->num_heredocs = counts.heredoc_c;
	cmd->heredoc_delimiters = NULL;
	cmd->heredoc_quotes = NULL;
	cmd->args = malloc(sizeof(char *) * (counts.arg_c + 1));
	cmd->red_in = malloc(sizeof(char *) * (counts.in_c + 1));
	cmd->red_out = malloc(sizeof(char *) * (counts.out_c + 1));
	cmd->append = malloc(sizeof(int) * (counts.out_c + 1));
	if (counts.heredoc_c > 0)
	{
		cmd->heredoc_delimiters = malloc(sizeof(char *)
				* (counts.heredoc_c + 1));
		cmd->heredoc_quotes = malloc(sizeof(int) * counts.heredoc_c);
	}
	if (!cmd->args || !cmd->red_in || !cmd->red_out || !cmd->append
		|| (counts.heredoc_c > 0
			&& (!cmd->heredoc_delimiters || !cmd->heredoc_quotes)))
	{
		free(cmd->args);
		free(cmd->red_in);
		free(cmd->red_out);
		free(cmd->append);
		free(cmd->heredoc_delimiters);
		free(cmd->heredoc_quotes);
		return (0);
	}
	return (1);
}


// Path: ./srcs/c_hamou/free.c
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   free.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: oadouz <oadouz@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/12 02:20:47 by oait-si-          #+#    #+#             */
/*   Updated: 2025/07/10 13:24:33 by oadouz           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "header.h"

void	free_tokens(t_token *tokens)
{
	t_token	*tmp;

	while (tokens)
	{
		tmp = tokens;
		tokens = tokens->next;
		free(tmp->value);
		free(tmp);
	}
}

void	free_double(char **arr)
{
	int	i;

	if (!arr)
		return ;
	i = 0;
	while (arr[i])
	{
		free(arr[i]);
		i++;
	}
	free(arr);
}

void	free_command(t_command *cmd)
{
	if (!cmd)
		return ;
	if (cmd->cmd)
		free(cmd->cmd);
	free_double(cmd->args);
	free_double(cmd->red_in);
	free_double(cmd->red_out);
	if (cmd->append)
		free(cmd->append);
	free_double(cmd->heredoc_delimiters);
	if (cmd->heredoc_quotes)
		free(cmd->heredoc_quotes);
	if (cmd->heredoc_tmp_file)
	{
		unlink(cmd->heredoc_tmp_file);
		free(cmd->heredoc_tmp_file);
	}
	if (cmd->next)
		free_command(cmd->next);
	free(cmd);
}

char	*skip_space(char *str)
{
	while (*str && is_space(*str))
		str++;
	return (str);
}

int	count_char(char *str)
{
	int	i;
	int	j;

	i = 0;
	j = 0;
	while (str[i])
	{
		if (is_space(str[i]))
		{
			j++;
			while (str[i] && is_space(str[i]))
				i++;
		}
		else
		{
			j++;
			i++;
		}
	}
	return (j);
}


// Path: ./srcs/c_hamou/helper_fuc.c
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   helper_fuc.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: oait-si- <oait-si-@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/21 16:34:08 by oait-si-          #+#    #+#             */
/*   Updated: 2025/07/11 06:01:47 by oait-si-         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "header.h"

void	handle_question_mark(char **end, t_data *data)
{
	char	*status_str;

	status_str = question_mark(data->ex_status);
	data->is_expanded = 1;
	if (data->accumulator)
		data->accumulator = join_and_free(data->accumulator, status_str);
	else
		data->accumulator = status_str;
	(*end)++;
}

char	*join_and_free(char *acc, char *to_add)
{
	char	*new;

	new = ft_strjoin(acc, to_add);
	free(acc);
	free(to_add);
	return (new);
}

char	*append_char(char *str, char c)
{
	char	ch[2];
	char	*new;

	ch[0] = c;
	ch[1] = '\0';
	if (!str)
		return (ft_strdup(ch));
	new = ft_strjoin(str, ch);
	free(str);
	return (new);
}

void	reset_word_data(t_data *data)
{
	free(data->accumulator);
	data->accumulator = NULL;
	data->is_expanded = 0;
	data->empty_expand = 0;
	data->quote_type = 0;
	data->is_assigning_expand = 0;
	data->has_whit_space = 0;
}

t_token	*create_and_add_token(t_token **tokens, t_token *token, t_data *data)
{
	if (!token)
	{
		free(data->accumulator);
		data->accumulator = NULL;
		free_tokens(*tokens);
		return (NULL);
	}
	add_token(tokens, token);
	return (*tokens);
}


// Path: ./srcs/c_hamou/tokenization.c
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   tokenization.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: oait-si- <oait-si-@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/12 02:12:47 by oait-si-          #+#    #+#             */
/*   Updated: 2025/07/11 03:38:45 by oait-si-         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "header.h"

void	singel_quotes_handler(char **input_start, t_data *data)
{
	char	*start;
	char	*end;
	char	*segment;

	data->quote_type = 1;
	start = *input_start + 1;
	end = start;
	while (*end && *end != '\'')
		end++;
	segment = ft_strndup(start, end - start);
	if (segment)
		data->accumulator = join_and_free(data->accumulator, segment);
	if (*end == '\'')
		*input_start = end + 1;
	else
		*input_start = end;
}

void	handle_double_quotes(char **start, char **env, t_data *data)
{
	char	*end;

	data->quote_type = 2;
	end = *start + 1;
	while (*end && *end != '"')
	{
		if (*end == '$' && !data->delimiter)
			handle_dollar_case(&end, env, data);
		else
		{
			data->accumulator = append_char(data->accumulator, *end);
			end++;
		}
	}
	if (*end == '"')
		*start = end + 1;
	else
		*start = end;
}

t_token	*handle_word(char **start, char **my_env, t_data *data)
{
	t_token	*token;

	reset_word_data(data);
	while (**start && !is_space(**start) && !is_operator(**start))
		process_segment(start, my_env, data);
	if (!data->accumulator)
	{
		if (data->is_expanded)
			data->empty_expand = 1;
		data->accumulator = ft_strdup("");
	}
	token = new_token(get_token_type(data->accumulator, data), data);
	free(data->accumulator);
	data->accumulator = NULL;
	return (token);
}

void	handle_quoted_part(char **start, char **env, t_data *data)
{
	if (**start == '\'')
		singel_quotes_handler(start, data);
	else if (**start == '"')
		handle_double_quotes(start, env, data);
}

t_token	*tokenize(char *line, char **my_env, t_data *data)
{
	t_token	*tokens;
	char	*start;
	t_token	*token;

	tokens = NULL;
	start = line;
	while (*start)
	{
		while (is_space(*start))
			start++;
		if (!*start)
			break ;
		if (is_operator(*start))
			token = handle_operator(&start, data);
		else
			token = handle_word(&start, my_env, data);
		if (!create_and_add_token(&tokens, token, data))
			return (NULL);
	}
	return (tokens);
}


// Path: ./srcs/c_hamou/tokens_utils1.c
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   tokens_utils1.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: oait-si- <oait-si-@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/12 23:46:06 by oait-si-          #+#    #+#             */
/*   Updated: 2025/07/11 04:02:55 by oait-si-         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "header.h"

void	handle_normal_char(char **end_ptr, t_data *data)
{
	if (data->accumulator)
		data->accumulator = append_char(data->accumulator, **end_ptr);
	else
		data->accumulator = ft_strndup(*end_ptr, 1);
	(*end_ptr)++;
}

int	get_operator_length(char **start, t_data *data)
{
	int	len;

	len = 1;
	if ((**start == '<' && *(*start + 1) == '<'))
	{
		len = 2;
		data->delimiter = 1;
	}
	else if (**start == '>' && *(*start + 1) == '>')
		len = 2;
	return (len);
}

void	process_operator_data(char *operator_str, t_data *data)
{
	data->accumulator = operator_str;
	data->quote_type = 0;
	data->is_expanded = 0;
	data->empty_expand = 0;
	data->is_assigning_expand = 0;
	data->has_whit_space = 0;
}

t_token	*handle_operator(char **start, t_data *data)
{
	char	*operator_str;
	int		len;
	t_token	*token;

	len = get_operator_length(start, data);
	operator_str = ft_strndup(*start, len);
	if (!operator_str)
		return (NULL);
	*start += len;
	process_operator_data(operator_str, data);
	token = new_token(get_token_type(data->accumulator, data), data);
	
	free(operator_str);
	data->accumulator = NULL;
	return (token);
}

void	remove_current_token(t_token **head, t_token **prev, t_token **current)
{
	t_token	*to_free;

	if (*prev)
		(*prev)->next = (*current)->next;
	else
		*head = (*current)->next;
	to_free = *current;
	*current = (*current)->next;
	to_free->next = NULL;
	free_tokens(to_free);
}

void	remove_empty_tokens(t_token **head)
{
	t_token	*current;
	t_token	*prev;

	if (!head || !*head)
		return ;
	current = *head;
	prev = NULL;
	while (current)
	{
		if (current->is_empty_after_expand && current->quotes_type == 0)
			remove_current_token(head, &prev, &current);
		else
		{
			prev = current;
			current = current->next;
		}
	}
}


// Path: ./srcs/c_hamou/tokens_utils2.c
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   tokens_utils2.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: oait-si- <oait-si-@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/12 02:16:02 by oait-si-          #+#    #+#             */
/*   Updated: 2025/07/11 04:01:54 by oait-si-         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "header.h"

void	handle_unquoted_part(char **start, char **env, t_data *data)
{
	char	*end;

	end = *start;
	data->quote_type = 0;
	while (*end && !is_space(*end) && !is_operator(*end) && !is_quotes(*end))
	{
		if(*end == '=' && *(end + 1) == '$')
			data->is_assigning_expand = 1;
		if (*end == '$' && (ft_isalpha(*(end + 1)) || *(end + 1) == '?')
			&& !data->delimiter)
			handle_dollar_case(&end, env, data);
		else
		{
			handle_normal_char(&end, data);
			data->delimiter = 0;
		}
	}
	*start = end;
}

void	process_segment(char **start, char **env, t_data *data)
{
	if (**start == '\'' || **start == '"')
		handle_quoted_part(start, env, data);
	else
		handle_unquoted_part(start, env, data);
}

t_token	*new_token(int type, t_data *data)
{
	t_token	*token;

	token = (t_token *)malloc(sizeof(t_token));
	if (!token)
		return (NULL);
	token->type = type;
	token->value = ft_strdup(data->accumulator);
	token->quotes_type = data->quote_type;
	token->is_expanded_token = data->is_expanded;
	token->is_empty_after_expand = data->empty_expand;
	token->is_assigning_expand_token = data->is_assigning_expand;
	token->has_whit_space = data->has_whit_space;
	token->next = NULL;
	return (token);
}

void	add_token(t_token **tokens, t_token *token)
{
	t_token	*tmp;

	if (!*tokens)
	{
		*tokens = token;
		return ;
	}
	tmp = *tokens;
	while (tmp->next)
		tmp = tmp->next;
	tmp->next = token;
}

int	get_token_type(char *line, t_data *data)
{
	if (ft_strcmp(line, "|") == 0 && data->quote_type == 0)
		return (T_PIPE);
	if (ft_strcmp(line, "<") == 0 && data->quote_type == 0)
		return (T_RED_IN);
	if (ft_strcmp(line, ">") == 0 && data->quote_type == 0)
		return (T_RED_OUT);
	if (ft_strcmp(line, "<<") == 0 && data->quote_type == 0)
		return (T_HEREDOC);
	if (ft_strcmp(line, ">>") == 0 && data->quote_type == 0)
		return (T_APPEND);
	return (T_WORD);
}


// Path: ./srcs/c_hamou/commands.c
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   commands.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: oait-si- <oait-si-@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/12 02:22:51 by oait-si-          #+#    #+#             */
/*   Updated: 2025/07/09 17:17:17 by oait-si-         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "header.h"

t_token	*process_token(t_token *token, t_command *cmd, t_indices *idx)
{
	if (token->type == TOKEN_WORD)
	{
		if (!cmd->cmd)
			cmd->cmd = ft_strdup(token->value);
		cmd->args[idx->i++] = ft_strdup(token->value);
		return (token->next);
	}
	return (handle_redirection(token, cmd, idx));
}

int	populate_command(t_command *cmd, t_token *tokens, t_counts counts)
{
	t_indices	idx;

	idx = (t_indices){0};
	if (!allocate_memory(cmd, counts))
		return (0);
	while (tokens && tokens->type != TOKEN_PIPE)
		tokens = process_token(tokens, cmd, &idx);
	terminate_arrays(cmd, &idx, counts);
	return (1);
}

int	should_skip_empty_command(t_cmd_builder *builder, t_token *first_word_token)
{
	if (builder->arg_count == 1 && builder->red_in_count == 0
		&& builder->red_out_count == 0 && builder->heredoc_count == 0
		&& first_word_token && first_word_token->is_empty_after_expand)
	{
		builder->current = NULL;
		builder->arg_count = 0;
		return (1);
	}
	return (0);
}

int	finalize_command(t_cmd_builder *builder)
{
	t_counts	counts;
	t_token		*first_word_token;

	if (!builder->current || (!builder->arg_count && !builder->red_in_count
			&& !builder->red_out_count && !builder->heredoc_count))
	{
		builder->current = NULL;
		return (1);
	}
	first_word_token = builder->tokens_start;
	while (first_word_token && first_word_token->type != TOKEN_PIPE)
	{
		if (first_word_token->type == TOKEN_WORD)
			break ;
		first_word_token = first_word_token->next;
	}
	if (should_skip_empty_command(builder, first_word_token))
		return (1);
	init_counts(&counts, builder);
	if (!populate_command(builder->current, builder->tokens_start, counts))
		return (0);
	terminate_arr_finalize_command(builder);
	return (1);
}

t_command	*build_command(t_token *tokens)
{
	t_cmd_builder	builder;

	builder = (t_cmd_builder){0};
	if (!tokens)
		return (NULL);
	while (tokens)
	{
		if (!ensure_command_exists(&builder, tokens))
			return (free_command(builder.commands), NULL);
		if (tokens->type == TOKEN_WORD)
			builder.arg_count++;
		else if (tokens->type == TOKEN_RED_IN && tokens->next)
			builder.red_in_count++;
		else if (tokens->type == TOKEN_RED_HEREDOC && tokens->next)
			builder.heredoc_count++;
		else if ((tokens->type == TOKEN_RED_OUT
				|| tokens->type == TOKEN_RED_APPEND) && tokens->next)
			builder.red_out_count++;
		if (tokens->type == TOKEN_PIPE || !tokens->next)
			if (!finalize_command(&builder))
				return (free_command(builder.commands), NULL);
		tokens = tokens->next;
	}
	return (builder.commands);
}


// Path: ./srcs/c_hamou/commands_utils1.c
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   commands_utils1.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: oadouz <oadouz@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/09 16:49:37 by oait-si-          #+#    #+#             */
/*   Updated: 2025/07/09 23:52:50 by oadouz           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "header.h"

t_token	*handle_redirection(t_token *token, t_command *cmd, t_indices *idx)
{
	if (token->type == TOKEN_RED_IN && token->next)
	{
		token = token->next;
		cmd->red_in[idx->j++] = ft_strdup(token->value);
		return (token->next);
	}
	if ((token->type == TOKEN_RED_OUT || token->type == TOKEN_RED_APPEND)
		&& token->next)
	{
		cmd->append[idx->append_idx++] = (token->type == TOKEN_RED_APPEND);
		token = token->next;
		cmd->red_out[idx->k++] = ft_strdup(token->value);
		return (token->next);
	}
	if (token->type == TOKEN_RED_HEREDOC && token->next)
	{
		token = token->next;
		cmd->heredoc_delimiters[idx->heredoc_idx] = ft_strdup(token->value);
		cmd->heredoc_quotes[idx->heredoc_idx] = (token->quotes_type != 0);
		idx->heredoc_idx++;
		return (token->next);
	}
	return (token->next);
}

void	terminate_arr_finalize_command(t_cmd_builder *builder)
{
	builder->current = NULL;
	builder->arg_count = 0;
	builder->red_in_count = 0;
	builder->red_out_count = 0;
	builder->heredoc_count = 0;
}

void	init_counts(t_counts *counts, t_cmd_builder *builder)
{
	counts->arg_c = builder->arg_count;
	counts->in_c = builder->red_in_count;
	counts->out_c = builder->red_out_count;
	counts->heredoc_c = builder->heredoc_count;
}


// Path: ./srcs/c_hamou/expand.c
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   expand.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: oait-si- <oait-si-@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/26 22:20:52 by oait-si-          #+#    #+#             */
/*   Updated: 2025/07/11 05:32:19 by oait-si-         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "header.h"

char	*get_var_value(char *new_word, char **envp)
{
	int	var_len;

	if (!new_word || !envp)
		return (NULL);
	var_len = ft_strlen(new_word);
	while (*envp)
	{
		if (ft_strncmp(*envp, new_word, var_len) == 0
			&& (*envp)[var_len] == '=')
			return (*envp + var_len + 1);
		envp++;
	}
	return (NULL);
}

void	handle_dollar_case(char **end, char **env, t_data *data)
{
	(*end)++;
	if (**end == '?')
		handle_question_mark(end, data);
	else if (ft_isalpha(**end))
		handle_regular_dollar(end, env, data);
	else if (ft_isdigit(**end))
	{
		(*end)++;
		return ;
	}
	else
		data->accumulator = append_char(data->accumulator, '$');
}

void	handle_regular_dollar(char **end, char **env, t_data *data)
{
	char	*var_start;

	var_start = *end;
	while (**end && ft_isalnum(**end))
		(*end)++;
	handle_regular_accumulator(var_start, *end, env, data);
}

void	handle_regular_accumulator(char *var_start, char *end,
			char **env, t_data *data)
{
	char	*var_name;
	char	*var_value;
	char	*tmp;

	var_name = ft_strndup(var_start, end - var_start);
	var_value = get_var_value(var_name, env);
	free(var_name);
	data->is_expanded = 1;
	if (var_value)
	{
		data->is_expanded = 1;
		if (data->accumulator)
		{
			tmp = data->accumulator;
			data->accumulator = ft_strjoin(tmp, var_value);
			free(tmp);
		}
		else
			data->accumulator = ft_strdup(var_value);
	}
}
int 	count_words_from_split(char **words)
{
	int i;
	
	i = 0;
	while(words[i])
		i++;
	return i;
}
void 	assign_values_to_prevent_ambigu(t_data *data)
{
	ft_bzero(data, sizeof(t_data));
	data->has_whit_space = 1;
}
t_token	*create_tokens_from_split(char **split_words)
{
	t_token	*head;
	int		i;
	t_data	temp_data;
	int 	count_words;
	int flag;
	count_words = count_words_from_split(split_words);
	head = NULL;
	i = 0;
	if(count_words > 1)
		flag = 1;
	if (!split_words || !split_words[0])
		return (NULL);
	while (split_words[i])
	{
		if(flag)
		{
			assign_values_to_prevent_ambigu(&temp_data);
			flag = 0;
		}
		else 
			ft_bzero(&temp_data, sizeof(t_data));
		temp_data.accumulator = split_words[i];
		add_token(&head, new_token(T_WORD, &temp_data));
		i++;
	}
	return (head);
}


// Path: ./srcs/c_spuvr/ft_export/ft_export.c
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_export.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: oadouz <oadouz@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/12 15:05:44 by oadouz            #+#    #+#             */
/*   Updated: 2025/06/21 17:21:51 by oadouz           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../built_functions.h"

int	is_standalone_name(const char *arg)
{
	if (!arg || !*arg)
		return (0);
	return (!ft_strchr(arg, '=') && !ft_strnstr(arg, "+=", ft_strlen(arg)));
}

int	exec_export_name_only(const char *name_arg, char ***env_ptr)
{
	if (!name_arg || name_arg[0] == '\0')
	{
		print_err_export(NULL, name_arg);
		return (1);
	}
	if (!is_valid_identifier(name_arg))
	{
		print_err_export(NULL, name_arg);
		return (1);
	}
	if (!my_getenv(name_arg, *env_ptr))
		return (my_setenv((char *)name_arg, NULL, env_ptr));
	return (0);
}

int	process_export_arguments(char **args, char ***env_ptr)
{
	int		i;
	int		ret_status;
	char	*current_arg;

	i = 1;
	ret_status = 0;
	while (args[i])
	{
		current_arg = args[i];
		if (is_standalone_name(current_arg))
			ret_status |= exec_export_name_only(current_arg, env_ptr);
		else if (ft_strnstr(current_arg, "+=", ft_strlen(current_arg)))
			ret_status |= exec_export_plus_equal(current_arg, env_ptr);
		else if (ft_strchr(current_arg, '='))
			ret_status |= exec_export_value(current_arg, env_ptr);
		else
			ret_status |= exec_export_name_only(current_arg, env_ptr);
		i++;
	}
	return (ret_status);
}

int	ft_export(char **args, char ***env_ptr)
{
	if (!env_ptr || !(*env_ptr))
		return (1);
	if (!args[1])
	{
		display_sorted_environment(*env_ptr);
		return (0);
	}
	return (process_export_arguments(args, env_ptr));
}


// Path: ./srcs/c_spuvr/ft_export/ft_export1.c
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_export1.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: oadouz <oadouz@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/12 15:05:55 by oadouz            #+#    #+#             */
/*   Updated: 2025/06/21 17:26:45 by oadouz           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../built_functions.h"

int	handle_equal_start(const char *value_ptr, int *status)
{
	char	*val_for_err;
	char	*err_str;

	val_for_err = strip_outer_quotes(value_ptr + 1);
	if (!val_for_err)
		return (1);
	err_str = ft_strjoin("=", val_for_err);
	if (!err_str)
	{
		free(val_for_err);
		return (1);
	}
	print_err_export(NULL, err_str);
	free(val_for_err);
	free(err_str);
	*status = 1;
	return (1);
}

int	exec_export_value(const char *arg, char ***env_ptr)
{
	char	*name;
	char	*value_ptr;
	char	*stripped_value;
	int		status;

	status = 0;
	value_ptr = ft_strchr(arg, '=');
	if (value_ptr == arg)
		return (handle_equal_start(value_ptr, &status));
	name = ft_substr(arg, 0, value_ptr - arg);
	if (!name)
		return (1);
	if (!is_valid_identifier(name))
	{
		print_err_export(NULL, name);
		free(name);
		return (1);
	}
	stripped_value = strip_outer_quotes(value_ptr + 1);
	if (!stripped_value)
		return (free(name), 1);
	status = my_setenv(name, stripped_value, env_ptr);
	free(name);
	free(stripped_value);
	return (status);
}


// Path: ./srcs/c_spuvr/ft_export/ft_export2.c
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_export2.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: oadouz <oadouz@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/15 17:37:18 by oadouz            #+#    #+#             */
/*   Updated: 2025/06/21 17:25:01 by oadouz           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../built_functions.h"

int	handle_plus_equal_error(const char *plus_equal_ptr, char *name)
{
	char	*val_for_err;
	char	*err_str;

	val_for_err = strip_outer_quotes(plus_equal_ptr + 2);
	if (!val_for_err)
	{
		free(name);
		return (1);
	}
	err_str = ft_strjoin("+=", val_for_err);
	if (!err_str)
	{
		free(val_for_err);
		free(name);
		return (1);
	}
	print_err_export(NULL, err_str);
	free(val_for_err);
	free(err_str);
	free(name);
	return (1);
}

int	create_append_value(char *name, char *append_val, char ***env_ptr)
{
	char	*old_val;
	char	*new_val_str;
	int		status;

	old_val = my_getenv(name, *env_ptr);
	if (!old_val)
		new_val_str = ft_strdup(append_val);
	else
		new_val_str = ft_strjoin(old_val, append_val);
	if (!new_val_str)
		return (1);
	status = my_setenv(name, new_val_str, env_ptr);
	free(new_val_str);
	return (status);
}

int	exec_export_plus_equal(const char *arg, char ***env_ptr)
{
	char	*name;
	char	*plus_equal_ptr;
	char	*stripped_value;
	int		status;

	plus_equal_ptr = ft_strnstr(arg, "+=", ft_strlen(arg));
	name = ft_substr(arg, 0, plus_equal_ptr - arg);
	if (!name)
		return (1);
	if (name[0] == '\0')
		return (handle_plus_equal_error(plus_equal_ptr, name));
	if (!is_valid_identifier(name))
	{
		print_err_export(NULL, name);
		free(name);
		return (1);
	}
	stripped_value = strip_outer_quotes(plus_equal_ptr + 2);
	if (!stripped_value)
		return (free(name), 1);
	status = create_append_value(name, stripped_value, env_ptr);
	free(name);
	free(stripped_value);
	return (status);
}


// Path: ./srcs/c_spuvr/ft_export/utils.c
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: oadouz <oadouz@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/12 16:26:37 by oadouz            #+#    #+#             */
/*   Updated: 2025/06/21 17:24:35 by oadouz           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../built_functions.h"

int	is_valid_identifier(const char *name)
{
	int	i;

	i = 0;
	if (!name || name[0] == '\0' || (!ft_isalpha(name[i]) && name[i] != '_'))
		return (0);
	i++;
	while (name[i])
	{
		if (!ft_isalnum(name[i]) && name[i] != '_')
			return (0);
		i++;
	}
	return (1);
}

char	*strip_outer_quotes(const char *str)
{
	size_t	len;
	int		has_quotes;

	if (!str)
		return (NULL);
	len = ft_strlen(str);
	has_quotes = 0;
	if (len >= 2)
	{
		if ((str[0] == '"' && str[len - 1] == '"')
			|| (str[0] == '\'' && str[len - 1] == '\''))
		{
			has_quotes = 1;
		}
	}
	if (has_quotes)
		return (ft_substr(str, 1, len - 2));
	return (ft_strdup(str));
}

void	print_err_export(const char *context, const char *specific_arg)
{
	ft_putstr_fd("minishell: export: ", STDERR_FILENO);
	if (context && context[0] != '\0')
	{
		ft_putstr_fd("`", STDERR_FILENO);
		ft_putstr_fd((char *)context, STDERR_FILENO);
		ft_putstr_fd("': ", STDERR_FILENO);
	}
	ft_putstr_fd("`", STDERR_FILENO);
	ft_putstr_fd((char *)specific_arg, STDERR_FILENO);
	ft_putstr_fd("': not a valid identifier\n", STDERR_FILENO);
}


// Path: ./srcs/c_spuvr/ft_export/utils2.c
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils2.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: oadouz <oadouz@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/15 17:40:41 by oadouz            #+#    #+#             */
/*   Updated: 2025/07/10 21:57:32 by oadouz           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../built_functions.h"

static void	swap_strings(char **a, char **b)
{
	char	*temp;

	temp = *a;
	*a = *b;
	*b = temp;
}

static void	ms_sort_env_array(char **arr_to_sort, int count)
{
	int		i;
	int		j;
	int		sorted;

	if (!arr_to_sort || count <= 1)
		return ;
	i = 0;
	while (i < count - 1)
	{
		sorted = 1;
		j = 0;
		while (j < count - 1 - i)
		{
			if (ft_strcmp(arr_to_sort[j], arr_to_sort[j + 1]) > 0)
			{
				swap_strings(&arr_to_sort[j], &arr_to_sort[j + 1]);
				sorted = 0;
			}
			j++;
		}
		if (sorted)
			break ;
		i++;
	}
}

static char	**ms_duplicate_env(char **original_env, int count)
{
	char	**new_env;
	int		i;

	new_env = (char **)malloc(sizeof(char *) * (count + 1));
	if (!new_env)
		return (NULL);
	i = 0;
	while (i < count)
	{
		new_env[i] = ft_strdup(original_env[i]);
		if (!new_env[i])
		{
			while (i > 0)
			{
				i--;
				free(new_env[i]);
			}
			free(new_env);
			return (NULL);
		}
		i++;
	}
	new_env[count] = NULL;
	return (new_env);
}

static void	ms_print_one_env_declare(char *env_str)
{
	int	i;

	ft_putstr_fd("declare -x ", STDOUT_FILENO);
	i = 0;
	while (env_str[i] && env_str[i] != '=')
	{
		ft_putchar_fd(env_str[i], STDOUT_FILENO);
		i++;
	}
	if (env_str[i] == '=')
	{
		ft_putchar_fd('=', STDOUT_FILENO);
		ft_putchar_fd('"', STDOUT_FILENO);
		i++;
		while (env_str[i])
		{
			if (env_str[i] == '"')
				ft_putstr_fd("\\\"", STDOUT_FILENO);
			else
				ft_putchar_fd(env_str[i], STDOUT_FILENO);
			i++;
		}
		ft_putchar_fd('"', STDOUT_FILENO);
	}
	ft_putchar_fd('\n', STDOUT_FILENO);
}

void	display_sorted_environment(char **envp)
{
	char	**env_copy;
	int		count;
	int		i;

	if (!envp)
		return ;
	count = ft_arrlen(envp);
	if (count == 0)
		return ;
	env_copy = ms_duplicate_env(envp, count);
	if (!env_copy)
		return ;
	ms_sort_env_array(env_copy, count);
	i = 0;
	while (i < count)
	{
		if (ft_strncmp(env_copy[i], "_=", 2) != 0)
			ms_print_one_env_declare(env_copy[i]);
		free(env_copy[i]);
		i++;
	}
	free(env_copy);
}


// Path: ./srcs/c_spuvr/ft_pipes/pipe_help.c
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   pipe_help.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: oadouz <oadouz@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/21 17:16:56 by oadouz            #+#    #+#             */
/*   Updated: 2025/07/10 00:19:57 by oadouz           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../built_functions.h"

void	setup_child_io(int prev_pipe, int *pipe_fds, t_command *cmd)
{
	if (prev_pipe != STDIN_FILENO)
	{
		if (dup2(prev_pipe, STDIN_FILENO) == -1)
			exit(1);
		close(prev_pipe);
	}
	if (cmd->next)
	{
		if (dup2(pipe_fds[1], STDOUT_FILENO) == -1)
			exit(1);
		close(pipe_fds[1]);
		close(pipe_fds[0]);
	}
}


// Path: ./srcs/c_spuvr/ft_pipes/pipe_execution.c
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   pipe_execution.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: oadouz <oadouz@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/28 17:44:44 by oadouz            #+#    #+#             */
/*   Updated: 2025/07/11 17:46:08 by oadouz           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../built_functions.h"

static void	execute_child(t_command *cmd, char ***env_ptr,
		int prev_pipe, int *pipe_fd)
{
	signal(SIGINT, SIG_DFL);
	signal(SIGQUIT, SIG_DFL);
	setup_child_io(prev_pipe, pipe_fd, cmd);
	child_process_logic(cmd, env_ptr);
}

static void	handle_parent_pipes(int *prev_pipe, int *pipe_fds, t_command *cmd)
{
	if (*prev_pipe != STDIN_FILENO)
		close(*prev_pipe);
	if (cmd->next)
	{
		close(pipe_fds[1]);
		*prev_pipe = pipe_fds[0];
	}
}

static int	wait_for_all_children(pid_t last_pid)
{
	int		status;
	int		last_status;
	pid_t	wpid;

	last_status = 1;
	wpid = 0;
	while (wpid != -1)
	{
		wpid = wait(&status);
		if (wpid == last_pid)
		{
			if (WIFEXITED(status))
				last_status = WEXITSTATUS(status);
			else if (WIFSIGNALED(status))
				last_status = 128 + WTERMSIG(status);
		}
	}
	return (last_status);
}

static pid_t	pipeline_loop(t_command *cmd, char ***env_ptr, int *prev_pipe)
{
	pid_t	pid;
	pid_t	last_pid;
	int		pipe_fds[2];

	last_pid = -1;
	while (cmd)
	{
		if (cmd->next && pipe(pipe_fds) == -1)
		{
			perror("minishell: pipe");
			return (-2);
		}
		pid = fork();
		if (pid < 0)
			return (perror("minishell: fork"), -1);
		if (pid == 0)
			execute_child(cmd, env_ptr, *prev_pipe, pipe_fds);
		last_pid = pid;
		handle_parent_pipes(prev_pipe, pipe_fds, cmd);
		cmd = cmd->next;
	}
	return (last_pid);
}

int	execute_pipeline(t_command *commands, char ***env_ptr, t_data *data)
{
	int		prev_pipe;
	pid_t	last_pid;
	int		final_status;

	(void)data;
	prev_pipe = STDIN_FILENO;
	signal(SIGINT, SIG_IGN);
	signal(SIGQUIT, SIG_IGN);
	last_pid = pipeline_loop(commands, env_ptr, &prev_pipe);
	if (last_pid < 0)
	{
		if (last_pid == -1)
			wait_for_all_children(0);
		return (1);
	}
	final_status = wait_for_all_children(last_pid);
	setup_signal_handlers();
	return (final_status);
}


// Path: ./srcs/c_spuvr/unset_exit/ft_unset.c
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_unset.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: oadouz <oadouz@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/13 16:33:39 by oadouz            #+#    #+#             */
/*   Updated: 2025/06/21 17:15:30 by oadouz           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../built_functions.h"

static int	process_unset_arg(char *arg, char ***env_ptr)
{
	if (!arg || !env_ptr || !(*env_ptr))
		return (0);
	my_unsetenv(arg, env_ptr);
	return (0);
}

int	ft_unset(char **args, char ***env_ptr)
{
	int	i;

	if (!args || !env_ptr || !(*env_ptr))
		return (0);
	i = 1;
	while (args[i])
	{
		process_unset_arg(args[i], env_ptr);
		i++;
	}
	return (0);
}


// Path: ./srcs/c_spuvr/unset_exit/ft_exit.c
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_exit.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: oadouz <oadouz@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/18 17:22:45 by oadouz            #+#    #+#             */
/*   Updated: 2025/07/11 21:37:13 by oadouz           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../built_functions.h"

int	is_numeric_arg(char *str)
{
	int	i;
	
	i = 0;
	if (!str || !*str)
		return (0);
	if (str[i] == '+' || str[i] == '-')
		i++;
	if (str[i] == '\0')
		return (0);
	while (str[i])
	{
		if (!ft_isdigit(str[i]))
			return (0);
		i++;
	}
	return (1);
}

static void	cleanup_and_exit(t_exit_data *exit_data)
{
	if (exit_data->env_ptr && *exit_data->env_ptr)
		free_environment(*(exit_data->env_ptr));
	if (exit_data->commands)
		free_command(exit_data->commands);
	if (exit_data->tokens)
		free_tokens(exit_data->tokens);
	exit(exit_data->data->ex_status);
}

static void	handle_exit_error(char *arg, t_exit_data *exit_data)
{
	ft_putstr_fd("minishell: exit: ", 2);
	ft_putstr_fd(arg, 2);
	ft_putendl_fd(": numeric argument required", 2);
	exit_data->data->ex_status = 2;
	cleanup_and_exit(exit_data);
}

static int	handle_exit_args(char **args, t_exit_data *exit_data)
{
	if (!is_numeric_arg(args[1]) || !is_valid_long_long(args[1]))
		handle_exit_error(args[1], exit_data);
	if (args[2])
	{
		ft_putendl_fd("minishell: exit: too many arguments", 2);
		exit_data->data->ex_status = 1;
		return (1);
	}
	exit_data->data->ex_status = (unsigned char)ft_atoll(args[1]);
	cleanup_and_exit(exit_data);
	return (0);
}

int	ft_exit(char **args, t_exit_data *exit_data)
{
	ft_putendl_fd("exit", 1);
	if (!args[1])
	{
		exit_data->data->ex_status = 0;
		cleanup_and_exit(exit_data);
	}
	return (handle_exit_args(args, exit_data));
}


// Path: ./srcs/c_spuvr/utils1.c
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils1.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: oadouz <oadouz@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/21 02:19:45 by oadouz            #+#    #+#             */
/*   Updated: 2025/07/10 16:11:06 by oadouz           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "built_functions.h"

static void	zft_initialize(int *i, int *s, unsigned long long *r)
{
	*i = 0;
	*s = 1;
	*r = 0;
}

int	shlvl_ft_atoi(const char *str)
{
	int					i;
	unsigned long long	r;
	int					s;

	zft_initialize(&i, &s, &r);
	while ((str[i] == 32) || (str[i] >= 9 && str[i] <= 13))
		i++;
	if ((str[i] == '-') || (str[i] == '+'))
	{
		if (str[i] == '-')
			s = -1;
		i++;
	}
	while (str[i] >= '0' && str[i] <= '9')
	{
		r = r * 10 + (str[i] - '0');
		if (r > 9223372036854775807 && s == -1)
			return (0);
		if (r > 9223372036854775807 && s == 1)
			return (0);
		i++;
	}
	return (r * s);
}

static void	handle_shlvl_update(char ***env_ptr)
{
	char	*val_shlvl;
	int		shlvl_nb;
	char	*new_shlvl;

	val_shlvl = my_getenv("SHLVL", *env_ptr);
	if (!val_shlvl || !ft_isdigit(*val_shlvl))
		my_setenv("SHLVL", "1", env_ptr);
	else
	{
		shlvl_nb = shlvl_ft_atoi(val_shlvl) + 1;
		new_shlvl = ft_itoa(shlvl_nb);
		if (new_shlvl)
		{
			my_setenv("SHLVL", new_shlvl, env_ptr);
			free(new_shlvl);
		}
	}
}

void	ensure_minimal_env(char ***env_ptr)
{
	char	*pwd_buffer;

	if (!my_getenv("PATH", *env_ptr))
		my_setenv("PATH", "/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin", env_ptr);
	handle_shlvl_update(env_ptr);
	if (!my_getenv("PWD", *env_ptr))
	{
		pwd_buffer = getcwd(NULL, 0);
		if (pwd_buffer)
		{
			my_setenv("PWD", pwd_buffer, env_ptr);
			free(pwd_buffer);
		}
	}
}


// Path: ./srcs/c_spuvr/ft_chdir/ft_cd_1.c
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_cd_1.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: oadouz <oadouz@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/15 17:04:45 by oadouz            #+#    #+#             */
/*   Updated: 2025/07/03 15:37:17 by oadouz           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../built_functions.h"


// Path: ./srcs/c_spuvr/ft_chdir/ft_cd.c
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_cd.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: oadouz <oadouz@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/15 17:04:48 by oadouz            #+#    #+#             */
/*   Updated: 2025/07/11 17:37:59 by oadouz           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../built_functions.h"

static char	*get_old_pwd_val(char **envp)
{
	char	*pwd_val;
	char	*pwd_copy;

	pwd_val = my_getenv("PWD", envp);
	if (pwd_val && *pwd_val)
	{
		pwd_copy = ft_strdup(pwd_val);
		return (pwd_copy);
	}
	pwd_copy = getcwd(NULL, 0);
	if (!pwd_copy)
	{
		ft_putstr_fd("minishell: cd : error retrieving current directory: ", 2);
		ft_putendl_fd(strerror(errno), 2);
	}
	return (pwd_copy);
}

static int	cd_err(const char *path, char *old_loc, char *to_free)
{
	ft_putstr_fd("minishell: cd: ", 2);
	ft_putstr_fd((char *)path, 2);
	ft_putstr_fd(": ", 2);
	ft_putendl_fd(strerror(errno), 2);
	return (1);
}

int	ft_chdir(char **args, char ***env_ptr)
{
	char	*dest;
	char	*old_loc;
	int		ret;
	char	*key_arg;

	old_loc = get_old_pwd_val(*env_ptr);
	dest = target_path(args, *env_ptr);
	if (!dest)
	{
		free(old_loc);
		return (1);
	}
	ret = chdir(dest);
	if (ret == -1)
	{
		cd_err(dest, old_loc, dest);
		free(old_loc);
		free(dest);
		return (1);
	}
	key_arg = args[1];
	if (!args[1] || (args[1] && ft_strcmp(args[1], "-") == 0))
		key_arg = dest;
	up_env_cd(old_loc, key_arg, env_ptr);
	return (free(old_loc), free(dest), 0);
}


// Path: ./srcs/c_spuvr/ft_chdir/ft_cd_utils.c
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_cd_utils.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: oadouz <oadouz@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/15 17:04:43 by oadouz            #+#    #+#             */
/*   Updated: 2025/07/11 22:11:47 by oadouz           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../built_functions.h"

static char	*get_path_from_home(char **envp)
{
	char	*path_val;

	path_val = my_getenv("HOME", envp);
	if (!path_val)
	{
		ft_putstr_fd("minishell: cd: HOME not set\n", 2);
		return (NULL);
	}
	if (path_val[0] == '\0')
		return (ft_strdup("."));
	return (ft_strdup(path_val));
}

static char	*get_path_from_oldpwd(char **envp)
{
	char	*path_val;

	path_val = my_getenv("OLDPWD", envp);
	if (!path_val || path_val[0] == '\0')
	{
		ft_putstr_fd("minishell: cd: OLDPWD not set\n", 2);
		return (NULL);
	}
	ft_putendl_fd(path_val, 1);
	return (ft_strdup(path_val));
}

static char	*get_path_from_tilde(const char *arg, char **envp)
{
	char	*path_val;
	char	*rest_of_path;
	char	*path;

	path_val = my_getenv("HOME", envp);
	if (!path_val || path_val[0] == '\0')
		return (ft_strdup(arg));
	rest_of_path = ft_substr(arg, 1, ft_strlen(arg) - 1);
	if (!rest_of_path)
		return (NULL);
	path = ft_strjoin(path_val, rest_of_path);
	free(rest_of_path);
	return (path);
}

char	*target_path(char **args, char **envp)
{
	if (!args[1] || args[1][0] == '\0')
		return (get_path_from_home(envp));
	if (ft_strcmp(args[1], "-") == 0)
		return (get_path_from_oldpwd(envp));
	if (args[1][0] == '~')
		return (get_path_from_tilde(args[1], envp));
	return (ft_strdup(args[1]));
}

static char	*join_pwd(const char *base, const char *arg)
{
	char	*tmp;
	char	*result;
	size_t	base_len;

	if (!arg && base)
		return (ft_strdup(base));
	if (!arg && !base)
		return (NULL);
	if (arg[0] == '/')
		return (ft_strdup(arg));
	if (!base || base[0] == '\0')
		return (ft_strdup(arg));
	base_len = ft_strlen(base);
	if (base_len > 0 && base[base_len - 1] == '/')
	{
		result = ft_strjoin(base, arg);
		return (result);
	}
	tmp = ft_strjoin(base, "/");
	if (!tmp)
		return (NULL);
	result = ft_strjoin(tmp, arg);
	free(tmp);
	return (result);
}

void	up_env_cd(char *old_pwd_val, const char *path_arg, char ***env_ptr)
{
	char	*new_pwd;
	char	*new_pwd_val;

	if (old_pwd_val && my_getenv("OLDPWD", *env_ptr) != NULL)
		my_setenv("OLDPWD", old_pwd_val, env_ptr);
	new_pwd = getcwd(NULL, 0);
	if (new_pwd)
	{
		if (my_getenv("PWD", *env_ptr) != NULL)
			my_setenv("PWD", new_pwd, env_ptr);
		free(new_pwd);
	}
	else
	{
		ft_putstr_fd("minishell: cd: error retrieving current directory: ", 2);
		ft_putendl_fd(strerror(errno), 2);
		new_pwd_val = join_pwd(old_pwd_val, path_arg);
		if (new_pwd_val)
		{
			if (my_getenv("PWD", *env_ptr) != NULL)
				my_setenv("PWD", new_pwd_val, env_ptr);
			free(new_pwd_val);
		}
	}
}


// Path: ./srcs/c_spuvr/ft_env/ft_env.c
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_env.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: oadouz <oadouz@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/18 16:33:39 by oadouz            #+#    #+#             */
/*   Updated: 2025/06/21 17:30:20 by oadouz           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../built_functions.h"

int	ft_env(char **args, char ***env_ptr)
{
	int		i;
	char	*eq_pos;

	if (!env_ptr || !(*env_ptr))
		return (1);
	i = 0;
	while ((*env_ptr)[i])
	{
		eq_pos = ft_strchr((*env_ptr)[i], '=');
		if (eq_pos)
			ft_putendl_fd((*env_ptr)[i], STDOUT_FILENO);
		i++;
	}
	return (0);
}


// Path: ./srcs/c_spuvr/ft_execut/error.c
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   error.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: oadouz <oadouz@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/22 17:24:16 by oadouz            #+#    #+#             */
/*   Updated: 2025/07/10 16:50:50 by oadouz           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../built_functions.h"

void	ft_free_array(char **array)
{
	int	i;

	if (!array)
		return ;
	i = 0;
	while (array[i])
	{
		free(array[i]);
		i++;
	}
	free(array);
}

int	handle_command_not_found(char *cmd)
{
	ft_putstr_fd("minishell : command not found\n", 2);
	return (127);
}

int	handle_fork_error(char *cmd_to_free)
{
	if (cmd_to_free)
		free(cmd_to_free);
	ft_putstr_fd("minishell: fork: ", 2);
	ft_putendl_fd(strerror(errno), 2);
	return (1);
}


// Path: ./srcs/c_spuvr/ft_execut/exec_main.c
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   exec_main.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: oadouz <oadouz@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/22 17:22:02 by oadouz            #+#    #+#             */
/*   Updated: 2025/07/08 18:32:10 by oadouz           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../built_functions.h"

static char	*join_path(char *dir, char *cmd)
{
	char	*tmp;
	char	*res;

	tmp = ft_strjoin(dir, "/");
	if (!tmp)
		return (NULL);
	res = ft_strjoin(tmp, cmd);
	free(tmp);
	return (res);
}

void	try_paths(char **paths, char *cmd, char **cmd_path)
{
	int	i;

	i = 0;
	while (paths[i])
	{
		*cmd_path = join_path(paths[i], cmd);
		if (*cmd_path && access(*cmd_path, X_OK) == 0)
			break ;
		free(*cmd_path);
		*cmd_path = NULL;
		i++;
	}
}

int	is_direct_path(const char *cmd_name)
{
	if (!cmd_name || !*cmd_name)
		return (0);
	return (cmd_name[0] == '/' || cmd_name[0] == '.'
		|| (cmd_name[0] == '.' && cmd_name[1] == '.'
			&& cmd_name[2] == '/'));
}

void	execute_child_process(char *cmd_path, char **args, char **envp)
{
	execve(cmd_path, args, envp);
	ft_putstr_fd(args[0], 2);
	if (errno == ENOEXEC)
	{
		ft_putstr_fd(": Exec format error\n", 2);
		exit(126);
	}
	ft_putstr_fd(": ", 2);
	ft_putendl_fd(strerror(errno), 2);
	if (errno == EACCES || errno == EISDIR || errno == ENOTDIR)
		exit(126);
	if (errno == ENOENT)
		exit(127);
	exit(1);
}


// Path: ./srcs/c_spuvr/ft_execut/util.c
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   util.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: oadouz <oadouz@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/21 16:20:30 by oadouz            #+#    #+#             */
/*   Updated: 2025/07/10 00:12:02 by oadouz           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../built_functions.h"

int	is_parent_only_builtin(char *cmd)
{
	if (!cmd)
		return (0);
	if (ft_strcmp(cmd, "cd") == 0)
		return (1);
	if (ft_strcmp(cmd, "export") == 0)
		return (1);
	if (ft_strcmp(cmd, "unset") == 0)
		return (1);
	return (0);
}

int	has_redirection(t_command *cmd)
{
	if ((cmd->red_in && cmd->red_in[0])
		|| (cmd->red_out && cmd->red_out[0])
		|| cmd->heredoc_delimiters)
		return (1);
	return (0);
}

char	*find_executable_path(char *cmd, char **envp)
{
	char	*path_env;
	char	**paths;
	char	*cmd_path;

	if (!cmd || !*cmd)
		return (NULL);
	path_env = my_getenv("PATH", envp);
	if (is_direct_path(cmd) || !path_env || !*path_env)
		return (ft_strdup(cmd));
	paths = ft_split(path_env, ':');
	if (!paths)
		return (NULL);
	cmd_path = NULL;
	try_paths(paths, cmd, &cmd_path);
	ft_free_array(paths);
	return (cmd_path);
}

int	wait_for_child(pid_t pid)
{
	int	status;

	waitpid(pid, &status, 0);
	if (WIFEXITED(status))
		return (WEXITSTATUS(status));
	if (WIFSIGNALED(status))
		return (128 + WTERMSIG(status));
	return (1);
}


// Path: ./srcs/c_spuvr/ft_execut/redirections.c
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   redirections.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: oadouz <oadouz@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/23 16:19:08 by oadouz            #+#    #+#             */
/*   Updated: 2025/07/10 13:33:16 by oadouz           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../built_functions.h"

static int	open_and_dup_input(char *filename)
{
	int	fd_in;

	fd_in = open(filename, O_RDONLY);
	if (fd_in == -1)
	{
		perror("minishell: open input file");
		return (0);
	}
	if (dup2(fd_in, STDIN_FILENO) == -1)
	{
		perror("minishell: dup2 stdin");
		close(fd_in);
		return (0);
	}
	close(fd_in);
	return (1);
}

static int	handle_input_redirection(t_command *cmd_node)
{
	int	i;
	int	status;

	if (!cmd_node->red_in || !cmd_node->red_in[0])
		return (1);
	i = 0;
	status = 1;
	while (cmd_node->red_in[i])
	{
		if (!open_and_dup_input(cmd_node->red_in[i]))
			status = 0;
		i++;
	}
	return (status);
}

static void	open_and_dup_output(char *filename, int flags)
{
	int	fd_out;

	fd_out = open(filename, flags, 0644);
	if (fd_out == -1)
	{
		perror("minishell: open output file");
		exit(1);
	}
	if (dup2(fd_out, STDOUT_FILENO) == -1)
	{
		perror("minishell: dup2 stdout");
		close(fd_out);
		exit(1);
	}
	close(fd_out);
}

static int	handle_output_redirection(t_command *cmd_node)
{
	int	flags;
	int	i;

	if (!cmd_node->red_out || !cmd_node->red_out[0])
		return (0);
	i = 0;
	while (cmd_node->red_out[i])
	{
		flags = O_WRONLY | O_CREAT;
		if (cmd_node->append && cmd_node->append[i])
			flags |= O_APPEND;
		else
			flags |= O_TRUNC;
		open_and_dup_output(cmd_node->red_out[i], flags);
		i++;
	}
	return (0);
}

int	handle_redirection_child(t_command *cmd_node)
{
	int	fd;
	int	status;

	status = 1;
	if (cmd_node->heredoc_tmp_file)
	{
		fd = open(cmd_node->heredoc_tmp_file, O_RDONLY);
		if (fd == -1)
		{
			perror("minishell: heredoc open");
			exit(1);
		}
		if (dup2(fd, STDIN_FILENO) == -1)
		{
			perror("minishell: dup2 heredoc");
			close(fd);
			exit(1);
		}
		close(fd);
		unlink(cmd_node->heredoc_tmp_file);
	}
	handle_output_redirection(cmd_node);
	if (!handle_input_redirection(cmd_node))
		status = 0;
	return (status);
}


// Path: ./srcs/c_spuvr/ft_execut/herdoc_utils.c
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   herdoc_utils.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: oadouz <oadouz@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/04 20:34:22 by oait-si-          #+#    #+#             */
/*   Updated: 2025/07/10 13:10:39 by oadouz           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../built_functions.h"

char	*generate_heredoc_filename(void)
{
	static int	num_heredocs;
	char		*num;
	char		*filename;

	num = ft_itoa(num_heredocs++);
	if (!num)
		return (NULL);
	filename = ft_strjoin("/tmp/.baya", num);
	free(num);
	return (filename);
}

void	process_heredoc_line(t_heredoc_info *info, char *line)
{
	if (info->fd != -1)
		re_process_heredoc_line(info, line);
	free(line);
}

void	read_heredoc_loop(t_heredoc_info *info)
{
	char	*line;

	while (1)
	{
		line = readline("> ");
		if (should_stop_reading(line, info))
		{
			free(line);
			break ;
		}
		process_heredoc_line(info, line);
	}
}


// Path: ./srcs/c_spuvr/ft_execut/herdoc_utils1.c
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   herdoc_utils1.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: oadouz <oadouz@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/09 23:02:29 by oadouz            #+#    #+#             */
/*   Updated: 2025/07/11 22:12:57 by oadouz           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../built_functions.h"

int	should_stop_reading(char *line, t_heredoc_info *info)
{
	return (!line
		|| ft_strcmp(line, info->cmd->heredoc_delimiters[info->i]) == 0);
}

void	expand_heredoc_line(char *line, char **env, t_data *data)
{
	char	*current;

	free(data->accumulator);
	data->accumulator = NULL;
	current = line;
	while (*current)
	{
		if (*current == '$' && (ft_isalpha(*(current + 1))
				|| *(current + 1) == '?' || *(current + 1) == '_'))
			handle_dollar_case(&current, env, data);
		else
			handle_normal_char(&current, data);
	}
	if (!data->accumulator)
		data->accumulator = ft_strdup("");
}

char	*setup_heredoc_to_file(t_command *cmd, char **envp, t_data *data)
{
	t_heredoc_info	info;
	char			*filename;

	filename = generate_heredoc_filename();
	if (!filename)
		return (NULL);
	info = (t_heredoc_info){-1, 0, cmd, envp, data};
	while (info.i < info.cmd->num_heredocs)
	{
		if (process_heredoc_iteration(&info, filename))
			return (free(filename), NULL);
		info.i++;
	}
	if (info.fd != -1)
		close(info.fd);
	return (filename);
}

void	re_process_heredoc_line(t_heredoc_info *info, char *line)
{
	if (info->cmd->heredoc_quotes[info->i] == 0)
	{
		expand_heredoc_line(line, info->envp, info->data);
		ft_putendl_fd(info->data->accumulator, info->fd);
	}
	else
	{
		ft_putendl_fd(line, info->fd);
	}
}

int	handle_heredocs_before_execution(t_command *cmds, char **envp,
	t_data *data)
{
	t_command	*current;

	current = cmds;
	while (current)
	{
		if (current->num_heredocs > 0)
		{
			free(current->heredoc_tmp_file);
			current->heredoc_tmp_file = setup_heredoc_to_file(current,
					envp, data);
			if (!current->heredoc_tmp_file)
				return (0);
		}
		current = current->next;
	}
	return (1);
}


// Path: ./srcs/c_spuvr/ft_execut/heredoc.c
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   heredoc.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: oadouz <oadouz@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/21 21:34:06 by oadouz            #+#    #+#             */
/*   Updated: 2025/07/11 22:14:30 by oadouz           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../built_functions.h"

int	g_sig_var;

void	heredoc_signals(int sig)
{
	(void)sig;
	write(1, "\n", 1);
	close(STDIN_FILENO);
	g_sig_var = 1;
}

void	handle_heredoc_interrupt(t_heredoc_info *info, int fd_backup)
{
	if (g_sig_var == 1)
	{
		dup2(fd_backup, STDIN_FILENO);
		info->data->ex_status = 130;
	}
}

void	read_heredoc_input(t_heredoc_info *info)
{
	int	fd_backup;

	g_sig_var = 0;
	fd_backup = dup(STDIN_FILENO);
	signal(SIGINT, &heredoc_signals);
	read_heredoc_loop(info);
	handle_heredoc_interrupt(info, fd_backup);
	setup_signal_handlers();
	close(fd_backup);
}

int	process_heredoc_iteration(t_heredoc_info *info, const char *filename)
{
	if (info->i == info->cmd->num_heredocs - 1)
	{
		info->fd = open(filename, O_WRONLY | O_CREAT | O_TRUNC, 0600);
		if (info->fd == -1)
			return (1);
	}
	read_heredoc_input(info);
	if (g_sig_var == 1)
	{
		if (info->fd != -1)
			close(info->fd);
		unlink(filename);
		return (1);
	}
	return (0);
}


// Path: ./srcs/c_spuvr/built-ins1.c
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   built-ins1.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: oadouz <oadouz@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/08 17:54:48 by oadouz            #+#    #+#             */
/*   Updated: 2025/05/26 17:10:47 by oadouz           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "built_functions.h"

int	is_built_ins(char **cmd, char ***env_ptr)
{
	if ((ft_strcmp(cmd[0], "export")) == 0)
		return (ft_export(cmd, env_ptr));
	else if ((ft_strcmp(cmd[0], "pwd")) == 0)
		return (ft_pwd(env_ptr));
	else if ((ft_strcmp(cmd[0], "cd")) == 0)
		return (ft_chdir(cmd, env_ptr));
	else if ((ft_strcmp(cmd[0], "unset")) == 0)
		return (ft_unset(cmd, env_ptr));
	else if ((ft_strcmp(cmd[0], "env")) == 0)
		return (ft_env(cmd, env_ptr));
	else if ((ft_strcmp(cmd[0], "echo")) == 0)
		return (ft_echo(cmd));
	return (999);
}


// Path: ./srcs/c_spuvr/env.c
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   env.c                                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: oadouz <oadouz@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/06 16:00:09 by oadouz            #+#    #+#             */
/*   Updated: 2025/07/10 10:16:48 by oadouz           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "built_functions.h"

char	*my_getenv(const char *name, char **envp)
{
	int	i;
	int	n_len;

	if (!name || !envp)
		return (NULL);
	i = 0;
	n_len = 0;
	while (name[n_len])
		n_len++;
	while (envp[i])
	{
		if (ft_strncmp(envp[i], name, n_len) == 0 && envp[i][n_len] == '=')
			return (&envp[i][n_len + 1]);
		i++;
	}
	return (NULL);
}

int	my_setenv(char *name, char *value, char ***env_ptr)
{
	int		var;
	char	*new_value;
	char	**new_data;

	if (!name || !env_ptr)
		return (-1);
	var = find_var_index(name, *env_ptr);
	new_value = create_env_data(name, value);
	if (!new_value)
		return (-1);
	if (var != -1)
	{
		free((*env_ptr)[var]);
		(*env_ptr)[var] = new_value;
		return (0);
	}
	var = ft_arrlen(*env_ptr);
	new_data = malloc((var + 2) * sizeof(char *));
	if (!new_data)
		return (free(new_value), -1);
	ft_memcpy(new_data, *env_ptr, var * sizeof(char *));
	new_data[var] = new_value;
	new_data[var + 1] = NULL;
	free(*env_ptr);
	return ((*env_ptr = new_data), 0);
}

static void	copy_indexes(char ***env_ptr, char **new_env, int skip_idx)
{
	int	i;
	int	j;

	i = 0;
	j = 0;
	while ((*env_ptr)[i])
	{
		if (i != skip_idx)
			new_env[j++] = (*env_ptr)[i];
		else
			free((*env_ptr)[i]);
		i++;
	}
	new_env[j] = NULL;
}

int	my_unsetenv(const char *name, char ***env_ptr)
{
	int		var_id;
	char	**new_env;
	int		env_size;

	if (!name || !env_ptr || !(*env_ptr))
		return (-1);
	var_id = find_var_index((char *)name, *env_ptr);
	if (var_id == -1)
		return (0);
	env_size = ft_arrlen(*env_ptr);
	new_env = malloc(sizeof(char *) * env_size);
	if (!new_env)
		return (-1);
	copy_indexes(env_ptr, new_env, var_id);
	free(*env_ptr);
	*env_ptr = new_env;
	return (0);
}


// Path: ./srcs/c_spuvr/utils.c
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: oadouz <oadouz@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/05 18:08:03 by oadouz            #+#    #+#             */
/*   Updated: 2025/07/10 11:04:30 by oadouz           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "built_functions.h"

char	*create_env_data(char *name, char *value)
{
	int		n_len;
	int		v_len;
	char	*entry;

	n_len = ft_strlen(name);
	v_len = ft_strlen(value);
	if (value == NULL)
	{
		entry = malloc (n_len + 1);
		if (!entry)
			return (NULL);
		ft_strlcpy(entry, name, n_len + 1);
	}
	else
	{
		entry = malloc(n_len + v_len + 2);
		if (!entry)
			return (NULL);
		ft_strlcpy(entry, name, n_len + 1);
		entry[n_len] = '=';
		ft_strlcpy(entry + n_len + 1, value, v_len + 1);
	}
	return (entry);
}

int	find_var_index(const char *name_to_find, char **envp)
{
	int	i;
	int	name_len;

	if (!name_to_find || !envp || name_to_find[0] == '\0')
		return (-1);
	name_len = 0;
	while (name_to_find[name_len])
		name_len++;
	i = 0;
	while (envp[i])
	{
		if (ft_strncmp(envp[i], name_to_find, name_len) == 0)
		{
			if (envp[i][name_len] == '\0' || envp[i][name_len] == '=')
			{
				return (i);
			}
		}
		i++;
	}
	return (-1);
}

char	**init_environment(char **system_envp)
{
	int		i;
	int		count;
	char	**copy;

	count = ft_arrlen(system_envp);
	copy = malloc((count + 1) * sizeof(char *));
	if (!copy)
		return (NULL);
	i = 0;
	while (i < count)
	{
		copy[i] = ft_strdup(system_envp[i]);
		if (!copy[i])
		{
			while (--i >= 0)
				free(copy[i]);
			free(copy);
			return (NULL);
		}
		i++;
	}
	copy[count] = NULL;
	return (copy);
}

void	free_environment(char **envp)
{
    int	i;

    if (!envp)
        return;
    i = 0;
    while (envp[i])
    {
        free(envp[i]);
        i++;
    }
    free(envp);
}


// Path: ./srcs/c_spuvr/execute_heart.c
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   execute_heart.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: oadouz <oadouz@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/04 15:31:37 by oadouz            #+#    #+#             */
/*   Updated: 2025/07/11 17:45:45 by oadouz           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "built_functions.h"
#include <sys/stat.h>

static int	is_directory(const char *path)
{
	struct stat	path_stat;

	if (stat(path, &path_stat) == 0)
	{
		if (S_ISDIR(path_stat.st_mode))
			return (1);
	}
	return (0);
}

static int	handle_directory_command(char *cmd_arg)
{
	if (is_directory(cmd_arg))
	{
		ft_putstr_fd("minishell: ", 2);
		ft_putstr_fd(cmd_arg, 2);
		ft_putstr_fd(": Is a directory\n", 2);
		return (126);
	}
	return (0);
}

static void	validate_and_execute(t_command *cmd, char **env)
{
	char	*cmd_path;

	cmd_path = find_executable_path(cmd->args[0], env);
	if (!cmd_path)
	{
		handle_command_not_found(cmd->args[0]);
		exit(127);
	}
	execute_child_process(cmd_path, cmd->args, env);
}

void    child_process_logic(t_command *cmd, char ***env)
{
	int	builtin_status;
	int	dir_status;

	if (!handle_redirection_child(cmd))
		exit(1);
	if (!cmd->cmd)
		exit(0);
	if (ft_strcmp(cmd->cmd, "exit") == 0)
	{
		if (!cmd->args[1])
			exit(0);
		if (!is_numeric_arg(cmd->args[1]))
			exit(255);
		if (cmd->args[2])
			exit(1);
		exit((unsigned char)ft_atoi(cmd->args[1]));
	}
	dir_status = handle_directory_command(cmd->args[0]);
	if (dir_status != 0)
		exit(dir_status);
	builtin_status = is_built_ins(cmd->args, env);
	if (builtin_status != 999)
		exit(builtin_status);
	validate_and_execute(cmd, *env);
}

int ft_execute_command_list(t_command *cmd_list, t_token *tokens, char ***env_ptr, t_data *data)
{
	pid_t	pid;
	int		status;

	if (!cmd_list)
		return (0);
	if (cmd_list->cmd && ft_strcmp(cmd_list->cmd, "exit") == 0 && !cmd_list->next)
	{
		t_exit_data exit_data;

		exit_data.env_ptr = env_ptr;
		exit_data.commands = cmd_list;
		exit_data.tokens = tokens;
		exit_data.data = data;
		return (ft_exit(cmd_list->args, &exit_data));
	}
	if (cmd_list->next)
		return (execute_pipeline(cmd_list, env_ptr, data));
	if (cmd_list->cmd && is_parent_only_builtin(cmd_list->cmd)
		&& !has_redirection(cmd_list))
		return (is_built_ins(cmd_list->args, env_ptr));
	pid = fork();
	if (pid == -1)
		return (handle_fork_error(NULL));
	if (pid == 0)
	{
		signal(SIGINT, SIG_DFL);
		signal(SIGQUIT, SIG_DFL);
		child_process_logic(cmd_list, env_ptr);
	}
	signal(SIGINT, SIG_IGN);
	signal(SIGQUIT, SIG_IGN);
	status = wait_for_child(pid);
	setup_signal_handlers();
	return (status);
}


// Path: ./srcs/c_spuvr/ft_echo.c
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_echo.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: oadouz <oadouz@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/11 02:24:47 by oadouz            #+#    #+#             */
/*   Updated: 2025/07/11 02:24:59 by oadouz           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "built_functions.h"

static char	*append_string(char *dest, char *src)
{
	char	*temp;
	char	*result;

	temp = dest;
	result = ft_strjoin(temp, src);
	free(temp);
	return (result);
}

static int	process_n_option(char **args)
{
	int	i;
	int	n_option;

	i = 1;
	n_option = 0;
	while (args[i] && is_nn_option(args[i]))
	{
		n_option = 1;
		i++;
	}
	return (n_option);
}

static int	skip_n_options(char **args)
{
	int	i;

	i = 1;
	while (args[i] && is_nn_option(args[i]))
		i++;
	return (i);
}

static char	*build_output_string(char **args, int start_index)
{
	char	*output_str;
	int		i;

	output_str = ft_strdup("");
	if (!output_str)
		return (NULL);
	i = start_index;
	while (args[i])
	{
		output_str = append_string(output_str, args[i]);
		if (!output_str)
			return (NULL);
		if (args[i + 1])
		{
			output_str = append_string(output_str, " ");
			if (!output_str)
				return (NULL);
		}
		i++;
	}
	return (output_str);
}

int	ft_echo(char **args)
{
	int		n_option;
	int		start_index;
	char	*output_str;

	n_option = process_n_option(args);
	start_index = skip_n_options(args);
	output_str = build_output_string(args, start_index);
	if (!output_str)
		return (1);
	if (n_option == 0)
	{
		output_str = append_string(output_str, "\n");
		if (!output_str)
			return (1);
	}
	write(STDOUT_FILENO, output_str, ft_strlen(output_str));
	free(output_str);
	return (0);
}


// Path: ./srcs/c_spuvr/built-ins.c
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   built-ins.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: oadouz <oadouz@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/08 15:20:01 by oadouz            #+#    #+#             */
/*   Updated: 2025/07/11 02:28:50 by oadouz           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "built_functions.h"

int	is_n_option(const char *arg)
{
	int	j;

	if (!arg || arg[0] != '-' || arg[1] != 'n')
		return (0);
	j = 2;
	while (arg[j])
	{
		if (arg[j] != 2)
			return (0);
		j++;
	}
	return (1);
}

int	is_nn_option(const char *arg)
{
	size_t	i;

	i = 0;
	if (!arg)
		return (0);
	if (arg[i] == '-')
	{
		i++;
		while (arg[i] == 'n')
			i++;
		if (arg[i])
			return (0);
		return (1);
	}
	return (0);
}

int	ft_pwd(char ***env_ptr)
{
	char	*current_pwd;
	char	*buffer;

	current_pwd = my_getenv("PWD", *env_ptr);
	if (current_pwd && *current_pwd)
	{
		ft_putstr_fd(current_pwd, STDOUT_FILENO);
		ft_putchar_fd('\n', STDOUT_FILENO);
		return (0);
	}
	else
	{
		buffer = getcwd(NULL, 0);
		if (buffer == NULL)
		{
			perror("minishell: pwd");
			return (1);
		}
		ft_putstr_fd(buffer, STDOUT_FILENO);
		ft_putchar_fd('\n', STDOUT_FILENO);
		free(buffer);
		return (0);
	}
}


// Path: ./srcs/c_spuvr/built_functions.h
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   built_functions.h                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: oadouz <oadouz@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/06 18:18:27 by oadouz            #+#    #+#             */
/*   Updated: 2025/07/11 22:14:05 by oadouz           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef BUILT_FUNCTIONS_H
# define BUILT_FUNCTIONS_H

# include <stdio.h>    
# include <stdlib.h>
# include <readline/readline.h>
# include <readline/history.h>
# include "../includes/header.h"
# include "../c_spuvr/LIBFT/libft.h"
# include "../includes/header.h"
# include <unistd.h>
# include <stdbool.h>
# include <errno.h>
# include <string.h>
# include <fcntl.h>
#include <signal.h>

typedef struct s_heredoc_info
{
	int			fd;
	int			i;
	t_command	*cmd;
	char		**envp;
	t_data		*data;
}				t_heredoc_info;

typedef struct s_exit_data
{
	char		***env_ptr;
	t_command	*commands;
	t_token		*tokens;
	t_data		*data;
}				t_exit_data;
int	is_nn_option(const char *arg);
// heredoc
void	expand_heredoc_line(char *line, char **env, t_data *data);
char	*generate_heredoc_filename(void);
void	handle_heredoc_interrupt(t_heredoc_info *info, int fd_backup);
int		process_heredoc_iteration(t_heredoc_info *info, const char *filename);
int		should_stop_reading(char *line, t_heredoc_info *info);
void	read_heredoc_loop(t_heredoc_info *info);
//built is
char	**init_environment(char **system_envp);
void	free_environment(char **envp_ptr);
char	*my_getenv(const char *name, char **envp);
char	*create_env_data(char *name, char *value);
int		find_var_index(const char *name_to_find, char **envp);
int		my_setenv(char *name, char *value, char ***env_ptr);
int		my_unsetenv(const char *name, char ***env_ptr);
int		ft_export(char **args, char ***env_ptr);
int		ft_pwd(char ***env_ptr);
int		ft_unset(char **args, char ***env_ptr);
int		ft_env(char **args, char ***env_ptr);
int ft_execute_command_list(t_command *command_list, t_token *tokens,
				char ***env_ptr, t_data *data);
char	*find_executable_path(char *cmd, char **envp);
int		wait_for_child(pid_t pid);
int		is_direct_path(const char *cmd_name);
// execute
void	read_heredoc_input(t_heredoc_info *info);
int		should_stop_reading(char *line, t_heredoc_info *info);
void	re_process_heredoc_line(t_heredoc_info *info, char *line);
void	handle_heredoc_interrupt(t_heredoc_info *info, int fd_backup);
char	*setup_heredoc_to_file(t_command *cmd, char **envp, t_data *data);
void	heredoc_signals(int sig);
int		is_parent_only_builtin(char *cmd);
int		has_redirection(t_command *cmd);
int		setup_heredoc(t_command *cmd, char **envp, t_data *data);
void	try_paths(char **paths, char *cmd, char **cmd_path);
//exit
int		ft_exit(char **args, t_exit_data *exit_data);
int		is_numeric_arg(char *str);

//cd 
void	up_env_cd(char *old_pwd_val, const char *path_arg, char ***env_ptr);
char	*target_path(char **args, char **envp);
// redirection
int		handle_redirection_child(t_command *cmd_node);
// pipe
int		execute_pipeline(t_command *commands, char ***env_ptr, t_data *data);
void	execute_single_cmd(t_command *cmd, char **envp);
void	setup_child_io(int prev_pipe, int *pipe_fds, t_command *cmd);
void    child_process_logic(t_command *cmd, char ***env);

// erro.c
void	ft_free_array(char **array);
int		handle_command_not_found(char *cmd);
void	execute_child_process(char *cmd_path, char **args, char **envp);
int		handle_fork_error(char *cmd_to_free);
int		ft_echo(char **args);
void	display_sorted_environment(char **envp);
int		process_export_arguments(char **args, char ***env_ptr);
int		is_standalone_name(const char *arg);
int		exec_export_plus_equal(const char *arg, char ***env_ptr);
int		exec_export_value(const char *arg, char ***env_ptr);
int		exec_export_name_only(const char *name_arg, char ***env_ptr);
void	print_err_export(const char *context, const char *specific_arg);
int		is_valid_identifier(const char *name);
int		handle_plus_equal_error(const char *plus_equal_ptr, char *name);
char	*strip_outer_quotes(const char *str);
int		create_append_value(char *name, char *append_val, char ***env_ptr);
int		is_built_ins(char **cmd, char ***env_ptr);
int		ft_chdir(char **args, char ***env_ptr);
void	ensure_minimal_env(char ***env_ptr);

#endif

// Path: ./srcs/includes/header.h
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   header.h                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: oadouz <oadouz@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/04 18:06:01 by oait-si-          #+#    #+#             */
/*   Updated: 2025/07/11 15:44:36 by oadouz           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef HEADER_H
#define HEADER_H

#include <stdio.h>
#include <stdlib.h>
#include <readline/readline.h>
#include <readline/history.h>
#include "../c_spuvr/LIBFT/libft.h"
#include <sys/wait.h>
#include <unistd.h>
#include <stdbool.h>
#include <signal.h>

#define TOKEN_WORD 0
#define TOKEN_PIPE 1
#define TOKEN_RED_IN 2 //<
#define TOKEN_RED_OUT 3//>
#define TOKEN_RED_APPEND 4 // >>
#define TOKEN_RED_HEREDOC 5 //<<


#define ERR_PIPE 1
#define ERR_RED 2
#define ERR_NEWLINE 5
#define ERR_QUOTE 6
#define ERR_SEMICOLON 7
#define ERR_SYNTAX 8 
#define ERR_AMBIGUOS 9

#define T_WORD    0
#define T_PIPE    1
#define T_RED_IN  2 // <
#define T_RED_OUT 3 // >
#define T_APPEND  4 // >>
#define T_HEREDOC 5


typedef struct s_data
{
	int	delimiter;
	int	ex_status;
	int	quote_type;
	char *accumulator;
	int 	empty_expand;
	int is_expanded;
	int     is_assigning_expand;
	int 	has_whit_space;
}	t_data;

typedef struct s_token
{
	int				type;
	char			*value;
	int				quotes_type;
	int				is_expanded_token;
	int				is_empty_after_expand;
	int				is_assigning_expand_token;
	int				has_whit_space;
	struct s_token	*next;
}	t_token;

typedef struct s_command
{
	char				*cmd;
	char				**args;
	char				**red_in;
	char				**red_out;
	int					*append;
	char				**heredoc_delimiters;
	int					*heredoc_quotes;
	int					num_heredocs;
	char				*heredoc_tmp_file;
	struct s_command	*next;
}	t_command;

typedef struct s_indices
{
	int	i;
	int	j;
	int	k;
	int	append_idx;
	int	heredoc_idx;
}	t_indices;

typedef struct s_counts
{
	int	arg_c;
	int	in_c;
	int	out_c;
	int	heredoc_c;
}	t_counts;

typedef struct s_cmd_builder
{
	t_command	*commands;
	t_command	*current;
	t_token		*tokens_start;
	int			arg_count;
	int			red_in_count;
	int			red_out_count;
	int			heredoc_count;
}	t_cmd_builder;
int 	count_char(char *str);
char	*skip_space(char *str);
void	setup_signal_handlers(void);

int			handle_heredocs_before_execution(t_command *cmds, char **envp,
				t_data *data);
t_token		*process_token(t_token *token, t_command *cmd, t_indices *idx);
t_token		*handle_redirection(t_token *token, t_command *cmd,
				t_indices *idx);
int			ensure_command_exists(t_cmd_builder *builder, t_token *token);
char		*append_char(char *str, char c);
int			finalize_command(t_cmd_builder *builder);
void        handle_quoted_part(char **start, char **env, t_data *data);
void        handle_unquoted_part(char **start, char **env, t_data *data);
void		handle_question_mark(char **end, t_data *data);
int			is_space(char c);
int			is_operator(char c);
int			is_quotes(char c);
void        handle_regular_dollar(char **end, char **env, t_data *data);

char		*join_and_free(char *acc, char *to_add);
char		*handle_double_quote_var(char **end, char **env, char *accumulator);
char		*handle_double_quote_dollar(char **end, char *accumulator, char **env, t_data *data);
void        handle_double_quotes(char **start, char **env, t_data *data);
void        singel_quotes_handler(char **input_start, t_data *data);
void		free_double(char **arr);
void		free_args(t_command *command);
char		*question_mark(int ex_status);
int			get_quotes_type(char quote_type);
void        process_segment(char **start, char **env, t_data *data);
t_token		*handle_operator(char **start, t_data *data);
char		*handle_double_quote_var1(char **end, char **env, t_data *data,
				char *accumulator);
t_token		*handle_word(char **start, char **my_env, t_data *data);
void        handle_dollar_case(char **end, char **env, t_data *data);
void	terminate_arrays(t_command *cmd, t_indices *idx, t_counts counts);
void        handle_normal_char(char **end_ptr, t_data *data);
void        handle_regular_accumulator(char *var_start, char *end, char **env, t_data *data);
int	allocate_memory(t_command *cmd, t_counts counts);
void		error(int type);
int			validate_syntax(t_token *tokens, t_data *data);
t_token		*tokenize(char *line, char **my_env, t_data *data);
void		free_tokens(t_token *tokens);
int			populate_command(t_command *cmd, t_token *tokens, t_counts counts);
t_token    *new_token(int type, t_data *data);
void		add_token(t_token **tokens, t_token *token);
int			get_token_type(char *line, t_data *data);
char		*expand_value_func(char *value, char **envp);
t_command	*build_command(t_token *tokens);
void		add_command(t_command **commands, t_command *command);
char		*get_var_value(char *new_word, char **envp);
void		free_command(t_command *cmd);
t_command	*new_command(void);
void	    setup_child_signals(t_command *cmd);
int			should_skip_empty_command(t_cmd_builder *builder,t_token *first_word_token);
void		remove_empty_tokens(t_token **head);
void	perform_field_splitting(t_token **tokens);
int	get_operator_length(char **start, t_data *data);
void 	terminate_arr_finalize_command(t_cmd_builder *builder);
void	init_counts(t_counts *counts, t_cmd_builder *builder);
void	process_operator_data(char *operator_str, t_data *data);
void	reset_word_data(t_data *data);
void	sigint_handler(int sig);
int	handle_quotes(char *line);
int	check_double_quotes(char *line, int *i);
t_token	*create_tokens_from_split(char **split_words);
int	check_invalid_char(char *line);
int	is_redirection(int token_type);
void	remove_current_token(t_token **head, t_token **prev, t_token **current);
int	should_skip_empty_command(t_cmd_builder *builder, t_token *first_word_token);
static void	main_loop(char ***my_envp, t_data *data);
t_token	*create_and_add_token(t_token **tokens, t_token *token, t_data *data);
void	exit_status(int set, int value, t_data *data);
void	sigint_handler_exec(int sig);

#endif


// Path: ./srcs/main_utils.c
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main_utils.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: oadouz <oadouz@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/10 05:53:01 by oait-si-          #+#    #+#             */
/*   Updated: 2025/07/10 13:35:58 by oadouz           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "c_spuvr/built_functions.h"

void	error(int type)
{
	if (type == ERR_PIPE)
		write(2, "Minishell: syntax error near unexpected token `|'\n", 50);
	else if (type == ERR_SEMICOLON)
		write(2, "Minishell: syntax error near unexpected token `;'\n", 51);
	else if (type == ERR_NEWLINE)
		write(2, "Minishell: syntax error near unexpected token `newline'\n", 57);
	else if (type == ERR_SYNTAX)
		write(2, "Minishell: syntax error \n", 26);
	else if (type == ERR_AMBIGUOS)
		write(2, "minishell: $...: ambiguous redirect\n", 36);
	else
		write(2, "Minishell: syntax error \n", 26);
}

int	check_single_quotes(char *line, int *i)
{
	(*i)++;
	while (line[*i])
	{
		if (line[*i] == '\'')
			return (1);
		(*i)++;
	}
	return (0);
}

int	check_double_quotes(char *line, int *i)
{
	(*i)++;
	while (line[*i])
	{
		if (line[*i] == '"')
			return (1);
		(*i)++;
	}
	return (0);
}

int	handle_quotes(char *line)
{
	int	i;

	i = -1;
	while (line[++i])
	{
		if (line[i] == '\'')
		{
			if (!check_single_quotes(line, &i))
				return (0);
		}
		if (line[i] == '"')
		{
			if (!check_double_quotes(line, &i))
				return (0);
		}
	}
	return (1);
}

int	check_invalid_char(char *line)
{
	int	i;

	i = -1;
	while (line[++i])
	{
		if (line[i] == ';' || line[i] == 92)
			return (0);
	}
	return (1);
}


// Path: ./srcs/main_utils2.c
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main_utils2.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: oadouz <oadouz@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/10 12:49:42 by oait-si-          #+#    #+#             */
/*   Updated: 2025/07/10 13:50:02 by oadouz           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "c_spuvr/built_functions.h"

// int	is_redirection(int token_type)
// {
// 	return (token_type == TOKEN_RED_IN
// 		|| token_type == TOKEN_RED_OUT
// 		|| token_type == TOKEN_RED_APPEND
// 		|| token_type == TOKEN_RED_HEREDOC);
// }

// int	validate_syntax(t_token *tokens)
// {
// 	t_token	*current;
// 	t_token	*next;

// 	current = tokens;
// 	while (current)
// 	{
// 		next = current->next;
// 		if (current->type == TOKEN_PIPE)
// 		{
// 			if (!next || next->type == TOKEN_PIPE)
// 				return (error(ERR_SYNTAX), 0);
// 		}
// 		else if (is_redirection(current->type))
// 		{
// 			if (!next)
// 				return (error(ERR_NEWLINE), 0);
// 			if (next->type != TOKEN_WORD)
// 				return (error(ERR_SYNTAX), 0);
// 			if (current->type != TOKEN_RED_HEREDOC
// 				&& next->is_empty_after_expand
// 				&& next->quotes_type == 0)
// 				return (error(ERR_AMBIGUOS), 0);
// 		}
// 		current = current->next;
// 	}
// 	return (1);
// }

// void	perform_field_splitting(t_token **tokens)
// {
// 	t_token	**current_ptr;
// 	t_token	*token_to_process;
// 	char	**split_words;
// 	t_token	*new_tokens;
// 	t_token	*end_of_new;

// 	current_ptr = tokens;
// 	while (*current_ptr)
// 	{
// 		token_to_process = *current_ptr;
// 		if (token_to_process->is_expanded_token
// 			&& token_to_process->quotes_type == 0)
// 		{
// 			split_words = ft_split(token_to_process->value, ' ');
// 			if (split_words && split_words[0] && split_words[1])
// 			{
// 				new_tokens = create_tokens_from_split(split_words);
// 				if (new_tokens)
// 				{
// 					end_of_new = new_tokens;
// 					while (end_of_new->next)
// 						end_of_new = end_of_new->next;
// 					end_of_new->next = token_to_process->next;
// 					*current_ptr = new_tokens;
// 					token_to_process->next = NULL;
// 					free_tokens(token_to_process);
// 					current_ptr = &end_of_new->next;
// 				}
// 			}
// 			if (split_words)
// 				free_double(split_words);
// 		}
// 		if (*current_ptr)
// 			current_ptr = &(*current_ptr)->next;
// 	}
// }

// void	main_loop(char ***my_envp, t_data *data)
// {
// 	char		*line;
// 	t_token		*tokens;
// 	t_command	*commands;

// 	while (1)
// 	{
// 		if (data->accumulator)
// 		{
// 			free(data->accumulator);
// 			data->accumulator = NULL;
// 		}
// 		line = readline("Minishell$ ");
// 		if (!line)
// 		{
// 			write(1, "exit\n", 5);
// 			free_environment(*my_envp);
// 			exit(data->ex_status);
// 		}
// 		if (*line)
// 			add_history(line);
// 		if (!handle_quotes(line) || !check_invalid_char(line))
// 		{
// 			if (!handle_quotes(line))
// 				write(2, "Minishell: Quotes aren't closed\n", 33);
// 			else
// 				write(2, "Minishell: Invalid character \n", 30);
// 			free(line);
// 			continue ;
// 		}
// 		tokens = tokenize(line, *my_envp, data);
// 		if (!tokens || !*line)
// 		{
// 			if (tokens)
// 				free_tokens(tokens);
// 			free(line);
// 			continue ;
// 		}
// 		commands = build_command(tokens);
// 		if (!commands)
// 		{
// 			free_tokens(tokens);
// 			free(line);
// 			continue ;
// 		}
// 		if (!validate_syntax(tokens, data))
// 		{
// 			free_command(commands);
// 			free_tokens(tokens);
// 			free(line);
// 			continue ;
// 		}
// 		if (!handle_heredocs_before_execution(commands, *my_envp, data))
// 		{
// 			free_command(commands);
// 			free_tokens(tokens);
// 			free(line);
// 			continue ;
// 		}
// 		remove_empty_tokens(&tokens);
// 		perform_field_splitting(&tokens);
// 		free_command(commands);
// 		commands = build_command(tokens);
// 		if (!commands)
// 		{
// 			free_tokens(tokens);
// 			free(line);
// 			continue ;
// 		}
// 		data->ex_status = ft_execute_command_list(commands, tokens, my_envp, data);
// 		free_command(commands);
// 		free_tokens(tokens);
// 		free(line);
// 	}
// }

// void debug_tokens(t_token *head)
// {
//     int index = 0;
//     t_token *current = head;

//     while (current != NULL)
//     {
//         printf("Token [%d]:\n", index);
//         printf("  type: %d\n", current->type);
//         printf("  value: %s\n", current->value ? current->value : "(null)");
//         printf("  quotes_type: %d\n", current->quotes_type);
//         printf("  is_expanded_token: %d\n", current->is_expanded_token);
//         printf("  next: %p\n", (void *)current->next);
//         printf("-----------------------\n");

//         current = current->next;
//         index++;
//     }

//     if (index == 0)
//         printf("No tokens to display (list is empty).\n");
// }

// Path: ./srcs/signal_handler.c
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   signal_handler.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: oadouz <oadouz@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/09 12:43:39 by oadouz            #+#    #+#             */
/*   Updated: 2025/07/10 21:03:43 by oadouz           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "includes/header.h"

void	setup_child_signals(t_command *cmd)
{
	if (ft_strnstr(cmd->cmd, "minishell", ft_strlen(cmd->cmd)))
	{
		signal(SIGINT, SIG_IGN);
		signal(SIGQUIT, SIG_IGN);
	}
	else
	{
		signal(SIGINT, SIG_DFL);
		signal(SIGQUIT, SIG_DFL);	
	}
}

void	sigint_handler_exec(int sig)
{
	(void)sig;
	write(1, "\n", 1);
}

void	sigint_handler(int sig)
{
	(void)sig;
	exit_status(1, 130, NULL);
	write(1, "\n", 1);
	rl_on_new_line();
	rl_replace_line("", 1);
	rl_redisplay();
}


// Path: ./srcs/main.c
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: oait-si- <oait-si-@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/04 18:26:38 by oait-si-          #+#    #+#             */
/*   Updated: 2025/07/11 05:57:03 by oait-si-         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "c_spuvr/built_functions.h"

void debug_tokens(t_token *head)
{
    int index = 0;
    t_token *current = head;

    while (current != NULL)
    {
        printf("Token [%d]:\n", index);
        printf("  type: %d\n", current->type);
        printf("  value: %s\n", current->value ? current->value : "(null)");
        printf("  quotes_type: %d\n", current->quotes_type);
        printf("  is_expanded_token: %d\n", current->is_expanded_token);
		printf("   has_whit_space %d\n", current->has_whit_space);
        printf("  next: %p\n", (void *)current->next);
        printf("-----------------------\n");

        current = current->next;
        index++;
    }

    if (index == 0)
        printf("No tokens to display (list is empty).\n");
}


int	is_redirection(int token_type)
{
	return (token_type == TOKEN_RED_IN
		|| token_type == TOKEN_RED_OUT
		|| token_type == TOKEN_RED_APPEND
		|| token_type == TOKEN_RED_HEREDOC);
}

int	validate_syntax(t_token *tokens,t_data *data)
{
	t_token	*current;
	t_token	*next;

	current = tokens;
		while (current)
	{
		next = current->next;
		if (current->type == TOKEN_PIPE)
		{
			if (!next || next->type == TOKEN_PIPE)
			{
				error(ERR_SYNTAX);
				data->ex_status = 2;
				return (0);
			}
		}
		else if (is_redirection(current->type))
		{
			// 1. Check for a missing token (e.g., ls >)
			if (!next)
			{
				data->ex_status = 2;
				error(ERR_NEWLINE);
				return (0);
			}

			// 2. Check that the following token is a WORD.
			if (next->type != TOKEN_WORD)
			{
				data->ex_status = 2;
				error(ERR_SYNTAX); // Or a more specific error
				return (0);
			}
			
			// 3. Check for the specific "ambiguous redirect" case.
			// This occurs if the filename token came from an unquoted variable
			// expansion that resulted in an empty string.
			if ((current->type != TOKEN_RED_HEREDOC && next->is_empty_after_expand && next->quotes_type == 0) 
				|| next->has_whit_space)
			{
				error(ERR_AMBIGUOS);
				data->ex_status = 1;
				return (0);
			}
		}
		current = current->next;
	}
		
	
	return (1);
}


void	exit_status(int set, int value, t_data *data)
{
	static int l;
	static t_data *hh;
	
	if (data)
		hh = data;
	if (set)
		hh->ex_status = value;
}



void	setup_signal_handlers(void)
{
	signal(SIGINT, sigint_handler);
	signal(SIGQUIT, SIG_IGN);
}

/**
 * @brief Iterates through the token list and performs field splitting on
 * unquoted, expanded variables.
 * @param tokens A pointer to the head of the token list. The list is modified
 * in place.
 */
void	perform_field_splitting(t_token **tokens)
{
	t_token	**current_ptr;
	t_token	*token_to_process;
	char	**split_words;

	current_ptr = tokens;
	while (*current_ptr)
	{
		token_to_process = *current_ptr;
		// This is the crucial condition for field splitting
		if (token_to_process->is_expanded_token
			&& token_to_process->quotes_type == 0 && !token_to_process->is_assigning_expand_token)
		{
			split_words = ft_split(token_to_process->value, ' ');
			// Only split if there is more than one resulting word
			if (split_words && split_words[0] && split_words[1])
			{
				t_token *new_tokens = create_tokens_from_split(split_words);
				if (new_tokens)
				{
					// Find the end of the newly created list
					t_token *end_of_new = new_tokens;
					while (end_of_new->next)
						end_of_new = end_of_new->next;
					
					// Link the end of the new list to the rest of the original list
					end_of_new->next = token_to_process->next;
					
					// Replace the old token with the new list of tokens
					*current_ptr = new_tokens;
					
					// Free the original token (decouple it first)
					token_to_process->next = NULL;
					free_tokens(token_to_process);
					
					// Move the main pointer to the end of the newly inserted list
					// to avoid re-processing the same tokens.
					current_ptr = &end_of_new->next;
				}
			}
			if (split_words)
				free_double(split_words); // Always free the split array
		}
		// If no splitting happened, just move to the next token
		if (*current_ptr)
			current_ptr = &(*current_ptr)->next;
	}
}
static void	main_loop(char ***my_envp, t_data *data)
{
	char		*line;
	t_token		*tokens;
	t_command	*commands;

	setup_signal_handlers();
	exit_status(0, 0, data);
	while (1)
	{
		// --- 1. Read Input ---
		if(data->accumulator)
		{
			free(data->accumulator);
			data->accumulator = NULL;
		}
		line = readline("Minishell$ ");
		if (!line)
		{
			write(1, "exit\n", 5);
			free_environment(*my_envp);
			exit(data->ex_status);
		}
		if (*line)
			add_history(line);
		
		// --- 2. Basic Input Checks ---
		if (!handle_quotes(line) || !check_invalid_char(line))
		{
			if (!handle_quotes(line))
			{
				data->ex_status = 2;
				write(2, "Minishell: Quotes aren't closed\n", 33);
			}
			else
			{
				data->ex_status = 2;
				write(2, "Minishell: Invalid character \n", 30);
			}
			free(line);
			continue ;
		}
		
		// --- 3. Tokenization ---
		tokens = tokenize(line, *my_envp, data);
		if (!tokens || !*line)
		{
			if (tokens)
				free_tokens(tokens);
			free(line);
			continue ;
		}
		if(tokens && tokens->type == T_PIPE)
		{
			error(ERR_PIPE);
			free_tokens(tokens);
			free(line);
			data->ex_status = 2;
			continue;
		}
		// debug_tokens(tokens);
		// --- 4. Build Initial Command Structure ---
		// This is needed to identify heredocs.
		commands = build_command(tokens);
		if (!commands) // Check if command building failed
		{	
			free_tokens(tokens);
			free(line);
			continue;
		}
		
		// --- 5. Handle Heredocs ---
		// This must run before syntax validation.
		
		// --- 6. Validate Syntax ---
		// This must run BEFORE removing empty tokens to catch ambiguous redirects.
		
		//debug_tokens(tokens);
		// --- 7. Post-Validation Processing ---
		remove_empty_tokens(&tokens);
		perform_field_splitting(&tokens);
		//debug_tokens(tokens);
		if (!validate_syntax(tokens, data))
		{
			free_command(commands);
			free_tokens(tokens);
			free(line);
			continue;
		}
		// --- 8. Re-build Command Structure ---
		// This is necessary because field splitting may have changed the tokens.
		free_command(commands);
		commands = build_command(tokens);
		if (!commands) // Check if the final command building failed
		{
			free_tokens(tokens);
			free(line);
			continue;
		}
		if (!handle_heredocs_before_execution(commands, *my_envp, data))
		{
			free_command(commands);
			free_tokens(tokens);
			free(line);
			continue ;
		}
		
		data->ex_status = ft_execute_command_list(commands, tokens, my_envp, data);
		
		// --- 10. Cleanup ---
		free_command(commands);
		free_tokens(tokens);
		free(line);
	}
}

void	debug_print_env(char **envp, const char *label)
{
	int	i;

	printf("--- DEBUG: %s ---\n", label);
	if (!envp)
	{
		printf(" (null)\n");
		return;
	}
	i = 0;
	while (envp[i])
	{
		printf("[%d]: %s\n", i, envp[i]);
		i++;
	}
	printf("--- END DEBUG ---\n\n");
}

int	main(int ac, char **av, char **env)
{
	char	**my_envp;
	t_data	data;
	if (!isatty(STDIN_FILENO) || !isatty(STDOUT_FILENO))
		exit(1);
	(void)ac;
	(void)av;
	my_envp = init_environment(env);
	ensure_minimal_env(&my_envp);
	data = (t_data){0};
	main_loop(&my_envp, &data);
	free_environment(my_envp);
	return (data.ex_status);
}


